\section{Python niveau 2!}


\subsection{Lire ou écrire dans un fichier}

\subsubsection{Écrire dans un fichier}

Écrire dans un fichier est ABSOLUMENT nécessaire pour pérenniser des données.
Cela est extrêmement simple à réaliser en Python.



\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{write.py}
\begin{verbatim}
f = open('file.txt', 'w')
f.write(a_value)
f.close()
\end{verbatim}
  \end{myterminalbox}
\end{center}

\subsubsection{Lire un fichier }

Lire un fichier est tout aussi simple toutefois, il existe plusieurs manière de lire un fichier.
Vous pouvez :
\begin{itemize}
\item Lire l'ensemble du fichier en une action \texttt{read()} pour remplir une variable de type \texttt{str}
\item Lire le fichier ligne à ligne \texttt{readline()} pour remplir plusieurs chaîne de charactère.\\
  Le retour chariot (\texttt{$\backslash$n}) délimite une ligne.
\item Lire l'ensemble du fichier pour remplir une liste de chaîne de charactère.
\end{itemize}


\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{read.py}
\begin{verbatim}
f = open('file.txt', 'r')
my_text = f.read()
f.close()
\end{verbatim}
  \end{myterminalbox}
\end{center}

\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{read.py}
\begin{verbatim}
f = open('file.txt', 'r')
a_line = f.readline()
f.close()
\end{verbatim}
  \end{myterminalbox}
\end{center}

\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{read.py}
\begin{verbatim}
f = open('file.txt', 'r')
list_of_line = f.readlines()
f.close()
\end{verbatim}
  \end{myterminalbox}
\end{center}


\subsubsection{Les modes d'ouvertures des fichiers}


\begin{description}
\item[w] ouverture en mode création du fichier puis écrire
\item[a] ouverture en mode écrire dans un fichier existant
\item[r] ouverture en mode lecture uniquement
\item[r+] ouverture en mode lecture/écriture
\end{description}







\subsection{Les boucles}

Assez rapidement, on doit se rendre compte qu'il est absolument nécessaire de répeter des tâches.


\subsubsection{For}

Il y a aussi en langage Python une structure \texttt{for} permettant de parcourir un nombre
fini d'éléments.
La structure générale de la boucle \texttt{for} est la suivante :
\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{principe}
\begin{verbatim}
for element in tableau :
    bloc instructions
\end{verbatim}
  \end{myterminalbox}
\end{center}

Le bloc d'instructions sera exécuté autant de fois qu'il y a de
valeur dans le tableau, chaque valeur étant placée tour à tour dans la
variable élément.
Les mots \texttt{for} et \texttt{in} sont les deux mots réservés utilisés dans cette structure.







\subsubsection{While}

Il est possible d’exécuter un même bloc d’instructions tant qu’une condition est
vérifiée grâce à la structure while dont voici la syntaxe :
\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{principe}
\begin{verbatim}
while condition :
    bloc_instructions
\end{verbatim}
  \end{myterminalbox}
\end{center}

la condition est d’abord évaluée et si elle vraie, le bloc
d’instructions est exécuté.
Après exécution du bloc d’instruction, la
condition est évaluée de nouveau et le bloc d’instructions est ré-exécuté tant que la
condition est vrai. Quand la condition devient fausse, le contrôle du programme passe
à l’instruction suivant le bloc while.

À noter qu'il est préférable que l'ensemble des instructions du bloc conditionné influent
sur la condition auquel, le programme se trouverait dans une \textit{boucle infinie}.



\subsection{Découverte du module matplotlib}


"Un scientifique sans graphique, c'est triste".


\subsubsection{Les courbes issues de coordonnées (x,y)}



\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{principe}
\begin{verbatim}
import matplotlib.pyplot as plt
x = [1,2,3,4,5,6,7,8,9,10]
y = [1.81,1.64,1.48,1.34,1.21,1.10,0.99,0.90,0.81,0.74]

plt.plot(x,y,'o')
plt.show()

\end{verbatim}
  \end{myterminalbox}
\end{center}
\begin{description}
\item[.] point marker
\item[,] pixel marker
\item[o] circle marker
\item[v] triangle\_down marker
\item[$\wedge$]  triangle\_up marker
\item[<] triangle\_left marker
\item[>] triangle\_right marker
\item[1] tri\_down marker
\item[2] tri\_up marker
\item[3] tri\_left marker
\item[4] tri\_right marker
\item[s] square marker
\item[p] pentagon marker
\item[*] star marker
\item[h] hexagon1 marker
\item[H] hexagon2 marker
\item[+] plus marker
\item[x] x marker
\item[D] diamond marker
\item[d] thin\_diamond marker
\item[|] vline marker
\item[\_] hline marker
\end{description}


\subsubsection{Les histogrammes}



\vskip 2pt
\begin{center}
  \begin{myterminalbox}[colback=gray!10]{principe}
\begin{verbatim}
import matplotlib.pyplot as plt
data = [0,7,2,5,1,3,5,6,3,4,1,8,9,1,4,2,6,3,8,4,5,3,]
plt.hist(data,normed=1)
plt.show()
\end{verbatim}
  \end{myterminalbox}
\end{center}
\vfill
